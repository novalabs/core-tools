# COPYRIGHT (c) 2016-2017 Nova Labs SRL
#
# All rights reserved. All use of this software and documentation is
# subject to the License Agreement located in the file LICENSE.

from novalabs.core.CoreUtils import *
from novalabs.core import CorePackage


class ModuleTargetGenerator:
    def __init__(self, obj: CorePackage):
        self.object = obj

        self.generated = False
        self.reason = ""

        self.destination = ""

        self.buffer = []

    def generate(self, out="", skip=False):
        self.generated = False
        if self.object.valid:
            try:
                if out == "":
                    out = os.path.join(self.workspace, self.object.name)
                else:
                    if not os.path.isdir(out):
                        os.mkdir(out)

                self.destination = os.path.join(out, "CMakeLists.txt")

                if not skip:
                    sink = open(self.destination, 'w')

                    self.__process()

                    sink.write("\n".join(self.buffer))
                    CoreConsole.ok("ModuleTarget::generate " + CoreConsole.highlightFilename(self.destination))
                else:
                    CoreConsole.ok("ModuleTarget::generate " + CoreConsole.highlightFilename(self.destination) + " SKIPPED")

                self.generated = True
            except IOError as e:
                self.reason = CoreConsole.error(str(e.strerror) + " [" + CoreConsole.highlightFilename(e.filename) + "]")
                CoreConsole.fail("ModuleTarget::generate: " + self.reason)

        return False

    def getSummaryGenerate(self, relpathSrc=None, relpathDst=None):
        if self.object.valid:
            if relpathSrc is not None:
                src = os.path.relpath(self.object.moduleTargetRoot, relpathSrc)
            else:
                src = os.path.relpath(self.object.moduleTargetRoot, relpathSrc)

            if relpathDst is not None:
                dst = os.path.relpath(self.destination, relpathDst)
            else:
                dst = self.destination

            if self.generated:
                return [self.object.type, CoreConsole.highlight(self.object.name), self.object.description, self.object.module, self.object.os_version, src, dst]
            else:
                return [self.object.type, CoreConsole.highlight(self.object.name), self.object.description, self.object.module, self.object.os_version, src, CoreConsole.error(self.reason)]
        else:
            return ["", "", CoreConsole.error(self.reason), "", "", ""]

    @staticmethod
    def getSummaryFieldsGenerate():
        return ["Type", "Name", "Description", "Module", "OS Version", "Root", "Generate"]

    # ---------------------------------------------------------------------------- #
    # --- PRIVATE ---------------------------------------------------------------- #
    # ---------------------------------------------------------------------------- #

    def __process(self):
        self.buffer = []
        if self.object.valid:
            self.__processPreamble()
            self.__processBootloaderAndConfiguration()
            self.__processIncludes()
            self.__processSources()
            self.__processCoreTarget()

    def __processPreamble(self):
        self.buffer.append('# Generated by ModuleTarget.py')
        self.buffer.append('# Remove a "#" from the line below to stop generating this file every time you call CoreWorkspace generate')
        self.buffer.append('## TARGET MODULE ' + self.object.module)
        self.buffer.append('')
        self.buffer.append('PROJECT( ' + self.object.name + ' )')
        self.buffer.append('CMAKE_MINIMUM_REQUIRED( VERSION 2.8 )')
        self.buffer.append('')
        self.buffer.append('FIND_PACKAGE( CORE_BUILD CONFIG REQUIRED )')
        self.buffer.append('')
        if self.object.type == "application":
            self.buffer.append('INCLUDE ( CoreTarget NO_POLICY_SCOPE )')
        elif self.object.type == "bootloader":
            self.buffer.append('INCLUDE ( CoreBootloaderTarget NO_POLICY_SCOPE )')
        self.buffer.append('')
        if self.object.type == "bootloader":
            self.buffer.append('SET( USE_SPECS "nano.specs")')
            self.buffer.append('')

    def __processBootloaderAndConfiguration(self):
        self.buffer.append('SET( BOOTLOADER_SIZE ' + str(self.object.bootloader_size) + ' )')
        self.buffer.append('SET( CONFIGURATION_SIZE ' + str(self.object.configuration_size) + ' )')
        self.buffer.append('SET( TAGS_SIZE ' + str(self.object.tags_size) + ' )')
        self.buffer.append('')

    def __processIncludes(self):
        self.buffer.append('SET( PROJECT_INCLUDE_DIRECTORIES')
        for x in self.object.includes:
            self.buffer.append('  ' + x)
        self.buffer.append(')')
        self.buffer.append('')

    def __processSources(self):
        self.buffer.append('SET( PROJECT_SOURCES')
        for x in self.object.sources:
            self.buffer.append('  ' + x)
        self.buffer.append(')')
        self.buffer.append('')

    def __processCoreTarget(self):
        if self.object.type == "application":
            self.buffer.append('core_target_module(')
        elif self.object.type == "bootloader":
            self.buffer.append('core_bootloader_target_module(')
        self.buffer.append('  MODULE ' + self.object.module)
        if self.object.os_version is not None:
            self.buffer.append('  OS_VERSION ' + self.object.os_version)
        if len(self.object.requiredPackages) > 0:
            self.buffer.append('  PACKAGES')
            for x in self.object.requiredPackages:
                self.buffer.append('    ' + x)
        if len(self.object.requiredOSComponents) > 0:
            self.buffer.append('  OS_COMPONENTS')
            for x in self.object.requiredOSComponents:
                self.buffer.append('    ' + x)
        self.buffer.append(')')
        self.buffer.append('')
